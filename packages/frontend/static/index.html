<!doctype html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/cal-heatmap/dist/cal-heatmap.css"
    />
    <title>Naruto Shippuuden</title>
  </head>
  <body>
    <main class="container mt-6">
      <div id="progress-wrapper" style="display: none">
        <h1 class="is-size-2">Status Naruto Shippuuden</h1>
        <h2 id="last-watched" class="is-size-3"></h2>
        <h3>
          W ciągu ostatniego tygodnia obejrzałem
          <span id="in-last-week"></span>
        </h3>
        <hr />
        <h3 class="pb-2">
          Obejrzałem już <span id="percent"></span> Naruto Shippuuden:
        </h3>
        <progress class="progress" id="progress" max="500"></progress>
        <hr />
        <div>
          <div id="ex-year" className="margin-bottom--md"></div>
          <div id="ex-year-legend" style="float: 'right'"></div>
        </div>

        <hr />
        <h2 id="last-updated" class="is-size-6"></h2>
      </div>
    </main>
  </body>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/cal-heatmap/dist/cal-heatmap.min.js"></script>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/cal-heatmap/dist/plugins/CalendarLabel.min.js"></script>
  <script src="https://unpkg.com/cal-heatmap/dist/plugins/Tooltip.min.js"></script>
  <script src="https://unpkg.com/cal-heatmap/dist/plugins/Legend.min.js"></script>

  <script>
    const fetchData = async () => {
      const feedUrl = `https://w6d9sazgkqmr96r5.public.blob.vercel-storage.com/feed/naruto.json?random=${Math.random()}`;
      const response = await fetch(feedUrl);
      return await response.json();
    };

    const fetchEpisodeTitle = async (episodeNumber) => {
      const narutoShippuudenId = 1735;
      const apiUrl = `https://api.jikan.moe/v4/anime/${narutoShippuudenId}/episodes/${episodeNumber}`;
      const response = await fetch(apiUrl);
      const json = await response.json();
      return json.data.title;
    };

    const prettyDate = (date) =>
      new Intl.DateTimeFormat('pl').format(new Date(date));

    const dayDifference = (start, end) => {
      const timeDifference = end - start;
      const daysDifference = timeDifference / (1000 * 3600 * 24);
      return daysDifference;
    };

    // taken from https://github.com/typeofweb/polish-plurals/blob/master/index.mjs
    const polishPlurals = (
      singularNominativ,
      pluralNominativ,
      pluralGenitive,
      value,
    ) => {
      value = Math.abs(value);
      if (value === 1) {
        return singularNominativ;
      } else if (
        value % 10 >= 2 &&
        value % 10 <= 4 &&
        (value % 100 < 10 || value % 100 >= 20)
      ) {
        return pluralNominativ;
      } else {
        return pluralGenitive;
      }
    };

    /**
     * Taken From https://stackoverflow.com/a/78704662
     * Adapted from https://stackoverflow.com/a/67374710/
     */
    const formatDate = (createTime) => {
      const millisecondsPerSecond = 1000;
      const secondsPerMinute = 60;
      const minutesPerHour = 60;
      const hoursPerDay = 24;
      const daysPerWeek = 7;
      const intervals = {
        week:
          millisecondsPerSecond *
          secondsPerMinute *
          minutesPerHour *
          hoursPerDay *
          daysPerWeek,
        day:
          millisecondsPerSecond *
          secondsPerMinute *
          minutesPerHour *
          hoursPerDay,
        hour: millisecondsPerSecond * secondsPerMinute * minutesPerHour,
        minute: millisecondsPerSecond * secondsPerMinute,
        second: millisecondsPerSecond,
      };
      const relativeDateFormat = new Intl.RelativeTimeFormat('pl', {
        style: 'long',
      });

      const diff = createTime - new Date();
      for (const interval in intervals) {
        if (intervals[interval] <= Math.abs(diff)) {
          return relativeDateFormat.format(
            Math.trunc(diff / intervals[interval]),
            interval,
          );
        }
      }
      return relativeDateFormat.format(diff / 1000, 'second');
    };

    const updateLastWatched = (response, episodeTitle) => {
      const lastWatchedEpisode = response.items[0];

      const wikiUrl = `https://naruto.fandom.com/wiki/${episodeTitle.replaceAll(' ', '_')}`;
      const lastWatchedEl = document.querySelector('#last-watched');
      const watchedDate = new Date(lastWatchedEpisode.pubDate);
      lastWatchedEl.innerHTML = `Ostatnio obejrzałem odcinek <a href="${wikiUrl}">#${lastWatchedEpisode.title} "${episodeTitle}"</a> ${formatDate(watchedDate)} (${prettyDate(watchedDate)})`;
    };

    const updateLastUpdatedEl = (response) => {
      const lastUpdatedEl = document.querySelector('#last-updated');
      lastUpdatedEl.textContent = `Ostatnia aktualizacja: ${formatDate(new Date(response.lastBuildDate))}`;
    };

    const updateProgressBar = (response) => {
      const lastWatchedEpisode = response.items[0];
      const progressEl = document.querySelector('#progress');
      progressEl.setAttribute('value', lastWatchedEpisode.title);

      const percentEl = document.querySelector('#percent');
      const lastEpNum = lastWatchedEpisode.title;
      const theProgress = (Number(lastEpNum) / 500) * 100;
      const rounded = (Math.round(theProgress * 100) / 100).toFixed(1);
      percentEl.textContent = `${rounded}%`;

      const wrapper = document.querySelector('#progress-wrapper');
      wrapper.style.display = 'block';
    };

    const howManyEpisodesInLastSevenDays = (response) => {
      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      const episodesInLastSevenDays = response.items.filter(
        (x) => new Date(x.pubDate) - sevenDaysAgo > 0,
      );
      document.querySelector('#in-last-week').textContent =
        `${episodesInLastSevenDays.length} ${polishPlurals('odcinek', 'odcinki', 'odcinków', episodesInLastSevenDays.length)}`;
    };

    const makeHeatmap = (firstEpisode) => {
      console.log(firstEpisode);
      const cal = new CalHeatmap();
      cal.paint(
        {
          data: {
            source: `https://w6d9sazgkqmr96r5.public.blob.vercel-storage.com/feed/naruto.tsv?random=${Math.random()}`,
            type: 'tsv',
            x: 'date',
            y: (d) => +d['watched'],
            groupY: 'max',
          },
          date: {
            start: new Date(firstEpisode),
            locale: 'pl',
          },
          range: 2,
          scale: { color: { type: 'linear', scheme: 'PRGn', domain: [0, 40] } },
          domain: {
            type: 'year',
            label: { text: null },
          },
          subDomain: { type: 'day', radius: 2 },
          itemSelector: '#ex-year',
        },
        [
          [
            Tooltip,
            {
              text: function (date, value, dayjsDate) {
                return (
                  (value ? value + '°C' : 'No data') +
                  ' on ' +
                  dayjsDate.format('LL')
                );
              },
            },
          ],
          [
            Legend,
            {
              tickSize: 0,
              width: 150,
              itemSelector: '#ex-year-legend',
            },
          ],
          [
            CalendarLabel,
            {
              width: 30,
              textAlign: 'start',
              text: () =>
                dayjs.weekdaysShort().map((d, i) => (i % 2 == 0 ? '' : d)),
            },
          ],
        ],
      );
    };

    const main = async () => {
      const result = await fetchData();

      const lastWatchedEpisode = result.items[0];
      const firstWatchedEpisodeDate = result.items.at(-1).pubDate;
      const episodeTitle = await fetchEpisodeTitle(lastWatchedEpisode.title);

      updateLastWatched(result, episodeTitle);
      updateLastUpdatedEl(result);
      updateProgressBar(result);
      howManyEpisodesInLastSevenDays(result);

      makeHeatmap(firstWatchedEpisodeDate);
    };
    main();
  </script>
</html>
